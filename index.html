<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador Gemini con Grounding</title>
    <!-- Carga de Tailwind CSS CDN para estilos responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Configuración de la fuente Inter y estilo de la barra de desplazamiento */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }
        /* Estilo para el área de salida del texto generado (pre-formato, manteniendo saltos de línea) */
        #output-text {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8 flex justify-center items-start">

    <!-- Contenedor Principal de la Aplicación -->
    <div class="w-full max-w-4xl bg-white shadow-2xl rounded-xl p-6 md:p-10">
        <header class="mb-8 border-b pb-4">
            <h1 class="text-3xl font-extrabold text-gray-900 mb-2">
                Generador de Contenido con Gemini
            </h1>
            <p class="text-gray-500">
                Escribe tu solicitud y usa la opción de "Grounding" para basar la respuesta en información web actual.
            </p>
        </header>

        <!-- Sección de Entrada (Input) -->
        <section class="mb-8">
            <label for="prompt-input" class="block text-lg font-medium text-gray-700 mb-3">
                Tu Solicitud (Prompt)
            </label>
            <textarea id="prompt-input" 
                      rows="5" 
                      placeholder="Ej: Escribe un resumen de las últimas noticias sobre la exploración de Marte."
                      class="w-full p-4 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 shadow-sm resize-none"
            ></textarea>

            <div class="mt-4 flex items-center justify-between">
                <div class="flex items-center">
                    <input id="use-grounding" type="checkbox" checked
                           class="h-5 w-5 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
                    <label for="use-grounding" class="ml-2 text-sm font-medium text-gray-700 select-none cursor-pointer">
                        Usar Google Search (Grounding)
                    </label>
                </div>
                
                <button id="generate-button"
                        class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition duration-300 ease-in-out transform hover:scale-105 active:scale-95 disabled:bg-indigo-400 disabled:cursor-not-allowed">
                    Generar Contenido
                </button>
            </div>
        </section>

        <!-- Sección de Salida (Output) -->
        <section class="mt-8 pt-6 border-t border-gray-200">
            <h2 class="text-2xl font-bold text-gray-900 mb-4">
                Respuesta de Gemini
            </h2>
            
            <!-- Indicador de Carga (Spinner) -->
            <div id="output-loading" class="hidden text-center p-6">
                <svg class="animate-spin h-8 w-8 text-indigo-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-2 text-indigo-600 font-medium">Procesando...</p>
            </div>

            <!-- Área de Texto Generado -->
            <div id="output-area" class="min-h-[150px] bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-inner">
                <p id="output-text" class="text-gray-700 leading-relaxed">
                    Presiona "Generar Contenido" para ver la respuesta.
                </p>
            </div>

            <!-- Fuentes de Grounding (Citas) -->
            <div id="sources-container" class="hidden mt-6 bg-indigo-50 p-4 rounded-lg border border-indigo-200">
                <h3 class="text-lg font-semibold text-indigo-800 mb-2">Fuentes Consultadas:</h3>
                <ul id="sources-list" class="list-disc pl-5 space-y-1 text-sm text-indigo-700">
                    <!-- Las fuentes se inyectarán aquí -->
                </ul>
            </div>
        </section>
    </div>

    <!-- Bloque de Script de Módulo (Contiene toda la lógica de api.js y main.js) -->
    <script type="module">
        // --- LÓGICA DE API.JS (Función de Llamada a Gemini) ---

        // Configuración del modelo y URL de la API
        const MODEL_NAME = "gemini-2.5-flash-preview-05-20";
        // La clave de API se inyecta automáticamente por el entorno si se deja vacía
        const apiKey = ""; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent`;


        /**
         * Envía un prompt a la API de Gemini y recupera el contenido generado y las fuentes (grounding).
         * Implementa el retroceso exponencial para reintentos.
         * @param {string} userQuery - El texto de la solicitud del usuario.
         * @param {boolean} useGrounding - Si es true, usa Google Search grounding.
         * @returns {Promise<{text: string, sources: Array<{uri: string, title: string}>}>}
         */
        async function generateContent(userQuery, useGrounding) {
            // Instrucción del sistema en español
            const systemPrompt = "Actúa como un asistente de IA útil, conciso y profesional. Responde directamente a la solicitud del usuario. Tu respuesta debe estar en español.";
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            // Añadir el tool de Google Search si se solicita Grounding
            if (useGrounding) {
                payload.tools = [{ "google_search": {} }];
            }

            let response;
            let retries = 0;
            const maxRetries = 3;

            while (retries < maxRetries) {
                try {
                    response = await fetch(`${API_URL}?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        // Lanzar un error para intentar de nuevo si no es 200
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    break; // Éxito: Salir del bucle

                } catch (error) {
                    retries++;
                    if (retries >= maxRetries) {
                        console.error("Máximo de reintentos alcanzado. Fallo en la solicitud.", error);
                        throw new Error("No se pudo conectar con el servicio de IA después de varios intentos.");
                    }
                    // Retroceso exponencial (Exponential backoff)
                    const delay = Math.pow(2, retries) * 1000;
                    console.log(`Reintentando en ${delay / 1000} segundos...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }


            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const text = candidate.content.parts[0].text;
                let sources = [];

                // Extracción de fuentes de Grounding
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title); // Filtrar fuentes válidas
                }

                return { text, sources };

            } else {
                // Manejar errores de la respuesta de la API
                const errorMessage = result.error?.message || "La respuesta de la IA no contiene texto válido o hubo un error en la solicitud. Revisa el log de la consola para más detalles.";
                throw new Error(errorMessage);
            }
        }


        // --- LÓGICA DE MAIN.JS (Manejo de UI y Eventos) ---

        // Selectores del DOM
        const promptInput = document.getElementById('prompt-input');
        const generateButton = document.getElementById('generate-button');
        const outputText = document.getElementById('output-text');
        const outputLoading = document.getElementById('output-loading');
        const sourcesContainer = document.getElementById('sources-container');
        const sourcesList = document.getElementById('sources-list');
        const useGroundingCheckbox = document.getElementById('use-grounding');

        /**
         * Muestra u oculta el indicador de carga y deshabilita/habilita el botón.
         * @param {boolean} isLoading - Si es true, muestra el spinner; si es false, lo oculta.
         */
        function toggleLoading(isLoading) {
            generateButton.disabled = isLoading;
            // Cambiar el texto del botón
            generateButton.textContent = isLoading ? 'Generando...' : 'Generar Contenido';
            // Mostrar/ocultar el spinner
            outputLoading.classList.toggle('hidden', !isLoading);
            
            // Limpiar el estado anterior
            if (isLoading) {
                outputText.textContent = 'Generando respuesta...';
                sourcesContainer.classList.add('hidden');
                sourcesList.innerHTML = '';
            }
        }

        /**
         * Muestra el error en la interfaz de usuario.
         * @param {string} message - El mensaje de error.
         */
        function displayError(message) {
            outputText.innerHTML = `<p class="text-red-600 font-semibold">Error: ${message}</p>`;
        }

        /**
         * Maneja el clic del botón de generación de contenido.
         */
        async function handleGenerateClick() {
            const userQuery = promptInput.value.trim();
            // Leer el estado del checkbox de grounding
            const useGrounding = useGroundingCheckbox.checked;

            if (!userQuery) {
                displayError("Por favor, ingresa una solicitud antes de presionar Generar.");
                return;
            }

            toggleLoading(true);

            try {
                // Llama a la función de la API
                const { text, sources } = await generateContent(userQuery, useGrounding);

                // Mostrar el texto generado
                outputText.textContent = text; 

                // Mostrar las fuentes si existen
                if (sources.length > 0) {
                    sourcesList.innerHTML = sources.map(source => 
                        `<li><a href="${source.uri}" target="_blank" class="text-indigo-600 hover:text-indigo-800 hover:underline transition duration-150">${source.title}</a></li>`
                    ).join('');
                    sourcesContainer.classList.remove('hidden');
                } else {
                    sourcesContainer.classList.add('hidden');
                }

            } catch (error) {
                console.error("Error al generar contenido:", error);
                displayError(error.message || "Ocurrió un error inesperado al comunicarse con la API.");
            } finally {
                toggleLoading(false);
            }
        }

        // Inicialización: Añadir los escuchadores de eventos al cargar la ventana
        window.onload = () => {
            generateButton.addEventListener('click', handleGenerateClick);
            // Permitir Enter para generar si el cursor está en el prompt, pero evitar el salto de línea.
            promptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleGenerateClick();
                }
            });
        };
    </script>
</body>
</html>
